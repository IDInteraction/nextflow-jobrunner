#!/usr/bin/env nextflow

/*
vim: syntax=groovy
-*- mode: groovy;-*-
*/


params.indir = "./participants/*"
params.eventfile = "./particiants/transitionannotations.csv"
params.manuscript = "manuscript.pdf"

/* How we handle the processing of, e.g. the Kinect data is going
to be tricky.  Make placeholder jobs, that just check for existance of
files/directories? */

/* A participant's data consists of:
webcam video
kinect front video
kinect side video
Series of frames for front depth
Series of frames for side depth
Ground truth data
*/


/* Will need to make a single participant's data flow through several
channels - e.g. each video stream, etc */

participant_dir = Channel.fromPath(params.indir, type: 'dir').map {
	path -> tuple(path.baseName, 
			path.toRealPath(),
			 path)
	}

keyframefile = Channel.fromPath(params.eventfile)

eventnames = Channel.from ("start1",
			"end1",
			"start2",
			"end2")


process enter_participant {
	input: 
	set participantcode, fullpath, path from participant_dir

	output:
	set participantcode, 'attention.txt' into attentionfile
	set participantcode, 'frontkinect.mp4', val("kinect"),
		val("front")  into frontkinectfile
	set participantcode, 'webcam.mp4', val("webcam"), val("front")  into webcamfile
	set participantcode, 'depthdata.tar' into depthfile

	"""
	# TODO - check each only matches a single file
	cat ${fullpath}/*_attention.txt > attention.txt
	cat ${fullpath}/*_kinect.mp4 > frontkinect.mp4
	cat ${fullpath}/*_webcam.mp4 > webcam.mp4
	tar czf depthdata.tar ${fullpath}/P??depth/*
	"""
}

attentionfile.into {attention_for_groundtruth; attention_for_events}

process attention_to_groundtruth {
	input:
	set val(participantcode), file(attentionfile) from attention_for_groundtruth

	output:
	file 'groundtruth.csv' into csvfile

	"""
	echo "groundtruth" > groundtruth.csv
	cat  ${attentionfile} >> groundtruth.csv
	"""
}

process extract_eventframe {
	input:
	file attentionfile from attention_for_events
	file keyframefile from keyframefile
	val event from eventnames

	output:
	set val(event), val(eventframe) into eventframe
	
	exec:
	eventframe = "123"

}

// Split channel so we can use it in following two filters
eventframe.into {eventframe1; eventframe2}
startevents = eventframe1.filter {it[0] =~/^start./}
endevents = eventframe2.filter{it[0] =~/^end./}

/*
process map_frame {
	// Transform a frame from Kinect to Webcam time 
	input:
	val kinectframe from kinectframe
	val participant from participant
	val map from mappingfile // Not sure how we'll implement this

	output:
	val webcamframe from eventframe
	
	exec:
	// Stuff to do the mapping
}
*/

// Combine both video sources
videofiles = frontkinectfile.mix(webcamfile)

// Combine all combinations of startevents and video sources
cppmt_runs = videofiles.combine(startevents)
// Run them
process run_cppmt {
	input:
	set val(event), val(eventframe) ,
val(participantcode), file(videofile), val(timebase),
		val(source) from cppmt_runs
	
	output:
	set participantcode, "cppmt_tracking.csv", timebase, source into cppmttrackingfile

	"""
	echo "Running cppmt tracking"
	echo "${videofile} ${event} ${eventframe}"
	echo "${participantcode}, ${timebase}"
	echo "${event}, ${eventframe}"
	echo "Cppmt tracking" > cppmt_tracking.csv
	cat ${videofile} >> cppmt_tracking
	echo ${event} >> cppmt_tracking
	echo ${eventframe} >> cppmt_tracking
	"""
}

process report_cppmt {
	input: 
	set val(participantcode), file("cppmttrack.csv"),
	val(timebase), val(source) from cppmttrackingfile

	exec:
	println participantcode
	println timebase
	println source

}

